<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>前端面试题集锦</title>
    <link type="text/css" rel="stylesheet" href="css/normalize.css">
    <link type="text/css" rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <!--<h1>前端面试题集锦</h1>-->
        <div class="content">
            <h2>前端开发知识点大纲：</h2>
            <p>HTML&CSS：  对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级及使用、HTML5、CSS3、移动端适应。</p>
            <p>JavaScript：   数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、内存泄漏、事件机制、异步装载回调、模板引擎、Nodejs、JSON、ajax等。</p>
            <p>其他：  HTTP、安全、正则、优化、重构、响应式、移动端、团队协作、可维护、SEO、UED、架构、职业生涯 </p>
        </div>
        <h2>HTML部分</h2>
        <div class="content">
            <h3>1.谈谈cookie的利弊</h3>
            <p>
                cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。
            </p>
            <P>1.IE6或更低版本最多20个cookie</P>
            <P>2.IE7和之后的版本最后可以有50个cookie。</P>
            <p>3.Firefox最多50个cookie</p>
            <p>4.chrome和Safari没有做硬性限制IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。</p>
            <p>cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节</p>
            <p>IE 提供了一种存储可以持久化用户数据，叫做uerData，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
            <h4>优点</h4>
            <p>1.通过良好的编程，控制保存在cookie中的session对象的大小。</p>
            <p>2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</p>
            <p>3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</p>
            <p>4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p>
            <h4>缺点</h4>
            <p>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。</p>
            <p>2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p>
            <p>3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
        </div>
        <div class="content">
            <h3>2.浏览器本地存储</h3>
            <p>在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。</p>
            <p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
            <p>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
        </div>
        <div class="content">
            <h3>3.web storage和cookie的区别</h3>
            <p>Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。 Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。</p>
            <p>除此之外， Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie 。</p>
            <p>但是 Cookie 也是不可以或缺的： Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生</p>
            <p>浏览器的支持除了 IE７ 及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的 UserData 其实就是 javascript 本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持 web storage 。</p>
            <p>localStorage 和 sessionStorage 都具有相同的操作方法，例如 setItem、getItem 和 removeItem 等</p>
        </div>
        <div class="content">
            <h3>4.对WEB标准以及W3C的理解与认识</h3>
            <p>标签闭合、标签小写、不乱嵌套、标签做到语义化,提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性;</p>
        </div>
        <div class="content">
            <h3>5.xhtml和html有什么区别</h3>
            <p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言</p>
            <p>最主要的不同：</p>
            <p>XHTML 元素必须被正确地嵌套。</p>
            <p>XHTML 元素必须被关闭。</p>
            <p>标签名必须用小写字母。</p>
            <p>XHTML 文档必须拥有根元素。</p>
        </div>
        <div class="content">
            <h3>6.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?</h3>
            <p>用于声明文档使用那种规范(html/Xhtml)一般为 严格 过度 基于框架的html文档,加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug</p>
        </div>
        <div class="content">
            <h3>7.什么是语义化的HTML?</h3>
            <p>直观的认识标签 对于搜索引擎的抓取有好处</p>
        </div>
        <div class="content">
            <h3>8.img标签上title与alt属性的区别是什么?</h3>
            <p>Alt 当图片不显示是 用文字代表。</p>
            <p>Title 为该属性提供信息</p>
        </div>
        <h2>CSS部分</h2>
        <div class="content">
            <h3>9.CSS 相关问题display:none和visibility:hidden的区别？</h3>
            <p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，
                就当他从来不存在。</p>
            <p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
        </div>
        <div class="content">
            <h3>10.CSS中 link 和@import 的区别是？</h3>
            <p>(1) link属于HTML标签，而@import是CSS提供的; </p>
            <p>(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>
            <p>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; </p>
            <p>(4) link方式的样式的权重 高于@import的权重.</p>
        </div>
        <div class="content">
            <h3>11.position的absolute与fixed共同点与不同点</h3>
            <h4>A：共同点：</h4>
            <p>1.改变行内元素的呈现方式，display被置为block；</p>
            <p>2.让元素脱离普通流，不占据空间； </p>
            <p>3.默认会覆盖到非定位元素上</p>
            <h4>B不同点：</h4>
            <p>absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
        </div>
        <div class="content">
            <h3>12.介绍一下CSS的盒子模型？</h3>
            <p>1）有两种， IE 盒子模型(也乘坐怪异盒模型)、标准 W3C 盒子模型；</p>
            <h4>正常盒模型</h4>
            <p>盒模型的大小包括content，padding，border，先做content。盒模型的大小会以内容优先自动扩展。内部子元素超过父元素给定的大小，会将父元素撑大。</p>
            <h4>怪异盒模型：</h4>
            <p>IE的content部分包含了 border 和 pading; 先做盒，然后添加border, padding，最后做content。保证盒模型优先，先做盒模型，内容放不下再说，手机上用的比较多。更通俗的说，如果父元素的盒模型确定，子元素是无法撑开父元素的盒模型的，只能在盒模型剩余的空间展示。</p>
        </div>
        <div class="content">
            <h3>13.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h3>
            <p>1.id选择器（ # myid）</p>
            <p>2.类选择器（.myclassname）</p>
            <p> 3.标签选择器（div, h1, p）</p>
            <p>4.相邻选择器（h1 + p）</p>
            <p>5.子选择器（ul < li）</p>
            <p>6.后代选择器（li a）</p>
            <p>7.通配符选择器（ * ）</p>
            <p>8.属性选择器（a[rel = "external"]）</p>
            <p>9.伪类选择器（a: hover, li: nth - child）</p>
            <p>可继承的样式： font-size font-family color, UL LI DL DD DT;</p>
            <p>不可继承的样式：border padding margin width height ;</p>
            <p>优先级就近原则，同权重情况下样式定义最近者为准;</p>
            <p>载入样式以最后载入的定位为准;</p>
            <h4>优先级为:</h4>
            <p>!important >  id > class > tag </p>
            <p>important 比 内联优先级高</p>
            <h4>CSS3新增伪类举例：</h4>
            <p>p:first-of-type 选择属于其父元素的首个元素的每个元素。</p>
            <p>p:last-of-type  选择属于其父元素的最后元素的每个元素。</p>
            <p>p:only-of-type  选择属于其父元素唯一的元素的每个元素。</p>
            <p>p:only-child	 选择属于其父元素的唯一子元素的每个元素。</p>
            <p>p:nth-child(2)  选择属于其父元素的第二个子元素的每个元素。</p>
            <p>:enabled  :disabled 控制表单控件的禁用状态。</p>
            <p>:checked		  单选框或复选框被选中。</p>
        </div>
        <div class="content">
            <h3>14.列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？</h3>
            <h4>display的值</h4>
            <p> block 象块类型元素一样显示</p>
            <p>none 缺省值。象行内元素类型一样显示。</p>
            <p> inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。</p>
            <p>list-item 象块类型元素一样显示，并添加样式列表标记。</p>
            <p>table像表格一样显示</p>
            <h4>position的值</h4>
            <p>*absolute
                生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p>
            <p> *fixed （老IE不支持）
                生成绝对定位的元素，相对于浏览器窗口进行定位。 </p>
            <p> *relative
                生成相对定位的元素，相对于其正常位置进行定位。 </p>
            <p>* static  默认值。没有定位，元素出现在正常的流中</p>
            <p>*（忽略 top, bottom, left, right z-index 声明）。</p>
            <p> * inherit 规定从父元素继承 position 属性的值。</p>

        </div>
        <div class="content">
            <h3>15.CSS3有哪些新特性？</h3>
            <p> CSS3实现圆角（border-radius:8px）</p>
            <p>阴影（box-shadow:10px） </p>
            <p>对文字加特效（text-shadow、） </p>
            <p>线性渐变（gradient） </p>
            <p>旋转（transform）
                transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 </p>
            <p>增加了更多的CSS选择器  多背景 rgba  </p>

        </div>
        <div class="content">
            <h3>16.对BFC规范的理解？ </h3>
            <p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
                （W3C CSS 2.1 规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关 系和相互作用。）</p>
        </div>
        <div class="content">
            <h3>14.解释下 CSS sprites，以及你要如何在页面或网站中使用它。</h3>
            <p>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。</p>
        </div>
        <div class="content">
            <h3>15.常见兼容性问题？</h3>
            <p>* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p>
            <p>* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。或者引入nomolize.css、reset.css</p>
            <p>* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 </p>
            <p>* 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）</p>
            <p>#box{ float:left; width:10px; margin:0 0 0 100px;} </p>
            <p> 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>

            <p>*  渐进识别的方式，从总体中逐渐排除局部。</p>
            <p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 </p>
            <p>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
            <p>css</p>
            <p>.bb{</p>
            <p>background-color:#f1ee18;/*所有识别*/</p>
            <p>.background-color:#00deff\9; /*IE6、7、8识别*/</p>
            <p>+background-color:#a200ff;/*IE6、7识别*/</p>
            <p>_background-color:#1e0bd1;/*IE6识别*/ </p>
            <p>} </p>
            <p>*  IE下,可以使用获取常规属性的方法来获取自定义属性,</p>
            <p>也可以使用getAttribute()获取自定义属性;</p>
            <p>Firefox下,只能使用getAttribute()获取自定义属性. </p>
            <p> 解决方法:统一通过getAttribute()获取自定义属性.</p>
            <p>* IE下,event对象有x,y属性,但是没有pageX,pageY属性; </p>
            <p> Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.</p>
            <p>* 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
            <p>* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,
                可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p>
            <p>* 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</p>
            <p>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p>
            <p>* 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p>
            <p>* 上下margin重合问题</p>
            <p>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。</p>
            <p>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>
            <p>* ie6对png图片格式支持不好(引用一段脚本处理)</p>

        </div>
        <div class="content">
            <h3>16.解释下浮动和它的工作原理？清除浮动的技巧 </h3>
            <p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 </p>
            <p>1.使用空标签清除浮动。 </p>
            <p>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签</p>
            <p>2.使用overflow。 </p>
            <p>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p>
            <p>3.使用after伪对象清除浮动。  </p>
            <p>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； </p>

        </div>
        <div class="content">
            <h3>17.浮动元素引起的问题和解决办法？</h3>
            <h4>浮动元素引起的问题：</h4>
            <p>（1）父元素的高度无法被撑开，影响与父元素同级的元素</p>
            <p>（2）与浮动元素同级的非浮动元素会跟随其后</p>
            <p>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p>
            <h4>解决方法：</h4>
            <p>使用 CSS 中的 clear:both ;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加 clearfix 样式：</p>
            <p>.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}</p>
            <p>.clearfix{display: inline-block;} /* for IE/Mac */</p>
        </div>
        <div class="content">
            <h3>18.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？ </h3>
            <p> FOUC - Flash Of Unstyled Content 文档样式闪烁 </p>
            <p>\< style type="text/css" media="all">@import "../fouc.css";\< /style></p>
            <p>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 </p>
            <p>解决方法简单的出奇，只要在< head>之间加入一个< link\>或者< script\>元素就可以了。 </p>
            <p> </p>
            <p> </p>
        </div>
        <h2>JavaScript部分</h2>
        <div class="content">
            <h3>19.new操作符具体干了什么呢? </h3>
            <p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 </p>
            <p> 2、属性和方法被加入到 this 引用的对象中。 </p>
            <p> 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
            <p>var obj  = {}; </p>
            <p>obj.__proto__ = Base.prototype; </p>
            <p>Base.call(obj); </p>
        </div>
        <div class="content">
            <h3>20.null和undefined的区别？</h3>
            <p>null 是一个表示"无"的对象，转为数值时为0；undefined 是一个表示"无"的原始值，转为数值时为 NaN 。 </p>
            <p>当声明的变量还未被初始化时，变量的默认值为 undefined 。</p>
            <p>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
            <p>undefined 表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是：</p>
            <p>（1）变量被声明了，但没有赋值时，就等于undefined。</p>
            <p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p>
            <p>（3）对象没有赋值的属性，该属性的值为undefined。</p>
            <p>（4）函数没有返回值时，默认返回undefined。</p>
            <p>null 表示"没有对象"，即该处不应该有值。典型用法是：</p>
            <p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
            <p>（2） 作为对象原型链的终点。</p>
        </div>
        <div class="content">
            <h3>21.JSON 的了解？</h3>
            <p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
                它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
                {'age':'12', 'name':'back'}</p>
        </div>
        <div class="content">
            <h3>22.js延迟加载的方式有哪些？</h3>
            <p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p>
        </div>
        <div class="content">
            <h3>23.如何解决跨域问题?</h3>
            <p> jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面jsonp的原理是动态插入script标签</p>
        </div>
        <div class="content">
            <h3>24.documen.write和 innerHTML的区别</h3>
            <p>document.write只能重绘整个页面</p>
            <p>innerHTML可以重绘页面的一部分</p>
        </div>
        <div class="content">
            <h3>25. .call() 和 .apply() 的区别和作用？</h3>
            <p>作用：动态改变某个类的某个方法的运行环境。</p>
        </div>
        <div class="content">
            <h3>26.哪些操作会造成内存泄漏？</h3>
            <p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
                垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
            <p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
                闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>

        </div>
        <div class="content">
            <h3>27.如何判断当前脚本运行在浏览器还是node环境中？</h3>
            <p>通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p>
        </div>
        <div class="content">
            <h3>28.javascript对象的几种创建方式</h3>
            <p>1，工厂模式</p>
            <p>2，构造函数模式</p>
            <p>3，原型模式</p>
            <p>4，混合构造函数和原型模式</p>
            <p>5，动态原型模式</p>
            <p>6，寄生构造函数模式</p>
            <p>7，稳妥构造函数模式</p>

        </div>
        <div class="content">
            <h3>29. javascript继承的6种方法</h3>
            <p>1，原型链继承</p>
            <p>2，借用构造函数继承</p>
            <p>3，组合继承(原型+借用构造)</p>
            <p>4，原型式继承</p>
            <p>5，寄生式继承</p>
            <p>6，寄生组合式继承</p>
        </div>
        <div class="content">
            <h3>30.ie各版本和chrome可以并行下载多少个资源</h3>
            <p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p>
            <p>Firefox，chrome也是6个</p>
        </div>
        <div class="content">
            <h3>31.GET和POST的区别，何时使用POST？</h3>
            <p> GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>
            <p> POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
            <p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，
                也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
            <p>然而，在以下情况中，请使用 POST 请求：</p>
            <p>无法使用缓存文件（更新服务器上的文件或数据库）</p>
            <p>向服务器发送大量数据（POST 没有数据量限制）</p>
            <p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
        </div>
        <div class="content">
            <h3></h3>
            <p></p>
        </div>
        <h6>The End!</h6>
        <hr>
    </div>
</body>
</html>